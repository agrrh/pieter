#!/usr/bin/env python3

import sys
import os
import subprocess
import yaml
import uuid

from sanic import Sanic
from sanic import response

DATA_STRUCT = {
    'repos': {}
}

def data_load(path='./data.yml'):
    if not os.path.exists(path):
        with open(path, 'a') as fp:
            fp.write(yaml.dump(DATA_STRUCT, default_flow_style=False))
        result = DATA_STRUCT
    else:
        with open(path, 'r') as fp:
            result = yaml.load(fp)
    return result

def data_save(path='./data.yml', data={}):
    with open(path, 'w') as fp:
        result = fp.write(yaml.dump(data, default_flow_style=False))
    return result

app = Sanic()

@app.route("/")
async def index(request):
    result = (
        'GET /repos',                       # Get repos list
        'PUT /repos/<name>',                # Create/update repo
        'DELETE /repos/<name>',             # Delete particular repo

        'PUT /repos/<name>/<scenario>',     # Create/update scenario for repo
        'GET /repos/<name>/<scenario>',     # Get scenario info
        'DELETE /repos/<name>/<scenario>',  # Delete scenario

        'PATCH /repos/<name>/<scenario>',   # Execute scenario

        'POST /hooks/<repo>/<scenario>'     # Almost the same, execute scenario
                                            # POST used for compability with VCS webhooks
                                            # Also, note 'hooks' part

        'GET /jobs/<uuid>'                  # Check job status
    )
    return response.json(result)

@app.route("/repos", methods=['GET'])
async def repos_index(request):
    data = data_load()

    if not request.json or 'name' not in request.json:
        code = 200
        result = data['repos']
    else:
        name = request.json['name']

        if name not in data['repos']:
            code = 404
            result = None
        else:
            code = 200
            result = data['repos'][name]

@app.route("/repos/<name>", methods=['GET', 'PUT', 'DELETE'])
async def repo_actions(request, name):
    if request.method == 'PUT':
        if not request.json or 'source' not in request.json:
            code = 400
            result = {'example': {
                'source': 'git@github.com/user/repo.git'
            }}
        else:
            data = data_load()
            source = request.json['source']

            repo_old = data['repos'][name] if name in data['repos'] else None

            repo_new = {
                'name': name,
                'source': source
            }

            if repo_new == repo_old:
                code = 200
            else:
                data['repos'][name] = repo_new
                data_save(data=data)
                code = 201

            result = {
                'old': repo_old,
                'new': repo_new
            }

    elif request.method == 'DELETE':
        data = data_load()
        name = request.json['name']

        if name not in data['repos']:
            code = 404
            result = None
        else:
            code = 200
            result = {
                'old': data['repos'][name],
                'new': None
            }
            data['repos'].pop(name, None)
            data_save(data=data)

    return response.json(result, status=code)

@app.route("/repos/<repo_name>/<scenario_name>", methods=['PUT', 'GET', 'DELETE', 'PATCH'])
async def scenario_actions(request, repo_name, scenario_name):
    scenario_path = '/'.join(('scenario', repo_name, scenario_name))

    if request.method == 'PUT':
        scenario_body = request.body

        if len(scenario_body) < 4 or len(scenario_body) > 10240:
            code = 400
            result = 'File size do not match sane limits'
        else:
            os.makedirs(os.path.dirname(scenario_path), mode=0o750)
            with open(scenario_path, 'wb') as fp:
                fp.write(scenario_body)
            os.chmod(scenario_path, 0o775)

            code = 201
            result = {
                'repo_name': repo_name,
                'scenario_name': scenario_name
            }

    elif request.method == 'GET':
        if not os.path.exists(scenario_path):
            code = 404
            result = None
        else:
            code = 200
            result = open(scenario_path, 'r').read()

    elif request.method == 'DELETE':
        if os.path.isfile(scenario_path):
            os.remove(scenario_path)
            code = 200
            result = {
                'repo_name': repo_name,
                'scenario_name': scenario_name,
                'state': 'removed'
            }
        else:
            code = 404
            result = None

    elif request.method == 'PATCH':
        job_name = str(uuid.uuid4())
        log_file = open('logs/{}.out.log'.format(job_name), 'a')
        err_file = open('logs/{}.err.log'.format(job_name), 'a')

        subprocess.Popen(
            'bash job.sh {} {}'.format(job_name, scenario_path),
            shell=True, stdout=log_file, stderr=err_file
        )

        code = 201
        result = {
            'job_name': job_name
        }

    return response.json(result, status=code)

@app.route("/jobs/<job_name>", methods=['GET', 'DELETE'])
async def job_actions(request, job_name):
    if request.method == 'GET':
        if not os.path.isfile('logs/{}.out.log'.format(job_name)):
            code = 404
            result = None
        else:
            job_result_path = 'logs/{}.result'.format(job_name)
            job_done = True if os.path.isfile(job_result_path) else False
            if job_done:
                duration, rc = open(job_result_path, 'r').read().strip().split(';')
                rc = int(rc)
            else:
                duration, rc = 0, None
            stdout = open('logs/{}.out.log'.format(job_name), 'r').read()
            stderr = open('logs/{}.err.log'.format(job_name), 'r').read()

            code = 200
            result = {
                'success': True if rc == 0 else False,
                'running': not job_done,
                'rc': rc,
                'duraion': duration,
                'stdout': stdout,
                'stderr': stderr
            }
    elif request.method == 'DELETE':
        if not os.path.isfile('logs/{}.out.log'.format(job_name)):
            code = 404
            result = None
        else:
            for extension in ('out.log', 'err.log', 'result'):
                file_path = 'logs/{}.{}'.format(job_name, extension)
                if os.path.isfile(file_path):
                    os.remove(file_path)

            code = 200
            result = job_name

    return response.json(result, status=code)

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=8000)
